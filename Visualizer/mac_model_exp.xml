<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>const int NR_NODES_SQR_ROOT = 4,
          NR_NODES = 16,
          NR_BEACON_SLOTS = 8,
          MAX_BEACON_NUMBER = 17;

//Durations
const int BEACON_PERIOD = 1000,
          BEACON_SLOT = 1,
          BEACON_SCAN = BEACON_SLOT * NR_BEACON_SLOTS,
          BEACON_SCAN_INTERVAL = 500,
          MAX_INIT_DELAY = 512,
          MAX_DATA_OFFSET = 63, // Multiplied later by 4 to get mS
          DATA_INTERVAL = 1000,
          DATA_DURATION = 1;

//Probability that a beacon is lost
const int BCN_LOST_PROB = 1,
          BCN_NOT_LOST_PROB = 99;

//Probability that a data package is lost
const int DATA_LOST_PROB = 1,
          DATA_NOT_LOST_PROB = 99;

//Type for node IDs
typedef int[0, NR_NODES-1] id_t;

//Type for beacons
typedef struct {
    int id;
    //Beacon synchronization is managed through clocks
    //Data Schedule is managed through array: data_is_scheduled[][]
} beacon_data;

//Global variable, holding sent beacon data
beacon_data sent_beacon;

broadcast chan 
    beacon_start_chan,                          //Begins sending beacon
    beacon_prepare_send_chan,                   //Prepare nodes to receive
    beacon_synchronize,                         //Tell synchronizer to test sync
    send_data_chan,                             //Data is being send
    stop_sending_data;                          //Force data sender to stop

//We pass the ID of the node as the index of the array
broadcast chan 
    end_initial_scan[NR_NODES],                 //End initial scan
    do_full_beacon_scan[NR_NODES],              //Begin or end full beacon scan
    do_initial_full_beacon_scan[NR_NODES],      //Begin initial full beacon scan
    end_initial_full_beacon_scan[NR_NODES],     //End initial full beacon scan
    do_beacon_scan[NR_NODES];                   //Initiate beacon scan

int aux_id = 0;                                 //Used for passing node id's
int own_sync_id = 0;                            //Own sync ID
int other_sync_id = 0;                          //Neighbor sync ID
int chosen_slot[NR_NODES];                      //Randomly chosen beacon slot
int beacon_period_counters[NR_NODES];           //Count toward full beacon scan
int data_intervals[NR_NODES];                   //Interval to send data for nodes
bool is_busy[NR_NODES];                         //One task at a time
int data_is_scheduled[NR_NODES][NR_NODES];      //Data schedules
int initialized[NR_NODES];                      //Initialized after initial scan

//Used to extract extra data
int nr_node_relations = 0;                      //Count of total network relations

//Clocks used by several templates
clock beacon_clocks[NR_NODES];                  //Manages beacon periods
clock send_data_clock[NR_NODES];                //Manage when the nodes sends data

//returns true if the nodes are connected
bool connected_check(int my_id, int other_id) {

//Report topology: Neighbors must be 7
//new_topology - 6 nodes
/*int connected[NR_NODES][NR_NODES] = {
        {0,0,1,1,1,0},
		{0,0,0,0,1,1},
		{1,0,0,1,0,0},
		{1,0,1,0,1,1},
		{1,1,0,1,0,1},
		{0,1,0,1,1,0}
};
return connected[my_id][other_id];*/

//Neocortec testbed - num_nodes_quadratic * num_nodes_quadratic nodes
    if(my_id % NR_NODES_SQR_ROOT == 0)
        return my_id-other_id == -1 || my_id-other_id == NR_NODES_SQR_ROOT || my_id-other_id == - NR_NODES_SQR_ROOT;
    if(my_id % NR_NODES_SQR_ROOT == NR_NODES_SQR_ROOT - 1)
        return my_id-other_id == 1 || my_id-other_id == NR_NODES_SQR_ROOT || my_id-other_id == - NR_NODES_SQR_ROOT;
    return my_id-other_id == -1 || my_id-other_id == 1 || my_id-other_id == NR_NODES_SQR_ROOT || my_id-other_id == - NR_NODES_SQR_ROOT;

//Two networks O-O
    if(my_id != other_id) {
        if(my_id &lt;= NR_NODES / 2 &amp;&amp; other_id &lt;= NR_NODES / 2) {
            return true;
        } 
        else if(my_id &gt; NR_NODES / 2 &amp;&amp; other_id &gt; NR_NODES / 2) {
            return true;
        }
        else if(my_id == NR_NODES / 2 &amp;&amp; other_id == (NR_NODES / 2) + 1 || my_id == (NR_NODES / 2) + 1 &amp;&amp; other_id == NR_NODES / 2) {
            return true;
        }
    }
    return false;

    //Line topology
    return my_id - other_id == 1 || my_id - other_id == -1;

}</declaration>
	<template>
		<name x="5" y="5">beacon_schedule</name>
		<parameter>id_t id</parameter>
		<location id="id0" x="-603" y="-510">
			<committed/>
		</location>
		<location id="id1" x="-314" y="-467">
			<name x="-297" y="-492">during_full_beacon_scan</name>
			<label kind="invariant" x="-297" y="-474">beacon_clocks[id] &lt;= BEACON_PERIOD</label>
		</location>
		<location id="id2" x="-960" y="-433">
			<name x="-1019" y="-442">initial</name>
			<label kind="invariant" x="-1019" y="-425">beacon_clocks[id] &lt;= MAX_INIT_DELAY</label>
		</location>
		<location id="id3" x="-76" y="-663">
			<name x="-289" y="-663">prepare_beacon_interval_start</name>
			<committed/>
		</location>
		<location id="id4" x="-637" y="-697">
			<name x="-807" y="-697">wait_for_beacon_interval</name>
			<label kind="invariant" x="-901" y="-680">beacon_clocks[id] &lt;= BEACON_PERIOD</label>
		</location>
		<location id="id5" x="-960" y="-544">
			<name x="-943" y="-552">during_initial_full_beacon_scan</name>
		</location>
		<init ref="id2"/>
		<transition>
			<source ref="id4"/>
			<target ref="id0"/>
			<label kind="guard" x="-595" y="-603">beacon_clocks[id] == BEACON_PERIOD
&amp;&amp; beacon_period_counters[id] 
== BEACON_SCAN_INTERVAL</label>
			<label kind="synchronisation" x="-596" y="-552">stop_sending_data!</label>
			<label kind="comments" x="-595" y="-620">Force send_data to continue</label>
			<nail x="-603" y="-595"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="guard" x="-518" y="-441">beacon_clocks[id] == BEACON_PERIOD</label>
			<label kind="assignment" x="-518" y="-424">beacon_period_counters[id] = 0,
is_busy[id] = false</label>
			<label kind="comments" x="-517" y="-458">End full beacon scan</label>
			<nail x="-637" y="-467"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="-483" y="-517">do_full_beacon_scan[id]!</label>
			<label kind="assignment" x="-483" y="-500">beacon_clocks[id] = 0</label>
			<label kind="comments" x="-484" y="-535">Do full beacon scan</label>
			<nail x="-603" y="-476"/>
			<nail x="-501" y="-475"/>
			<nail x="-339" y="-475"/>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id4"/>
			<label kind="guard" x="-960" y="-884">beacon_clocks[id] == BEACON_PERIOD
&amp;&amp; data_intervals[id] - BEACON_SCAN &lt;  send_data_clock[id]
&amp;&amp; beacon_period_counters[id] != BEACON_SCAN_INTERVAL</label>
			<label kind="assignment" x="-960" y="-833">beacon_clocks[id] = 0,
beacon_period_counters[id]++</label>
			<label kind="comments" x="-960" y="-901">Prioritize data over beacons</label>
			<nail x="-697" y="-748"/>
			<nail x="-960" y="-748"/>
			<nail x="-960" y="-791"/>
			<nail x="-637" y="-790"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id5"/>
			<label kind="synchronisation" x="-951" y="-493">do_initial_full_beacon_scan[id]!</label>
			<label kind="assignment" x="-951" y="-476">beacon_clocks[id] = 0</label>
			<label kind="comments" x="-951" y="-510">Begin initial scan</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="guard" x="-527" y="-739">beacon_clocks[id] == BEACON_PERIOD
&amp;&amp; beacon_period_counters[id] &lt; BEACON_SCAN_INTERVAL
&amp;&amp; data_intervals[id] - BEACON_SCAN &gt;= send_data_clock[id]</label>
			<label kind="synchronisation" x="-527" y="-688">beacon_prepare_send_chan?</label>
			<label kind="assignment" x="-527" y="-671">beacon_clocks[id] = 0</label>
			<label kind="comments" x="-527" y="-756">Other nodes are forced to enter beacon interval</label>
			<nail x="-561" y="-765"/>
			<nail x="-102" y="-765"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-255" y="-595">do_beacon_scan[id]!</label>
			<label kind="assignment" x="-255" y="-578">beacon_period_counters[id]++</label>
			<label kind="comments" x="-255" y="-612">Initiate beacon interval</label>
			<nail x="-102" y="-629"/>
			<nail x="-578" y="-629"/>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="guard" x="-527" y="-875">beacon_clocks[id] == BEACON_PERIOD
&amp;&amp; beacon_period_counters[id] &lt; BEACON_SCAN_INTERVAL
&amp;&amp; data_intervals[id] - BEACON_SCAN &gt;= send_data_clock[id]</label>
			<label kind="assignment" x="-527" y="-825">beacon_clocks[id] = 0</label>
			<label kind="comments" x="-527" y="-892">First node to enter beacon interval</label>
			<nail x="-569" y="-799"/>
			<nail x="-76" y="-799"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-943" y="-620">end_initial_full_beacon_scan[id]?</label>
			<label kind="assignment" x="-943" y="-603">is_busy[id] = false,
initialized[id] = true</label>
			<label kind="comments" x="-944" y="-637">Beacon initial scan</label>
			<nail x="-960" y="-697"/>
		</transition>
	</template>
	<template>
		<name>initial_full_beacon_scan</name>
		<parameter>id_t id</parameter>
		<declaration>const int NR_MAX_FULL_BEACON = 16,            //Max number of full beacon scans
          NR_BEACON_PERIOD_PER_SCAN = 3,      //Number of beacon periods per scan
          //The max number of beacon periods before initial full beacon scan ends
          NR_MAX_PERIOD = NR_MAX_FULL_BEACON 
                            * NR_BEACON_PERIOD_PER_SCAN 
                            - (NR_BEACON_PERIOD_PER_SCAN - 1);

int beacon_period_count = 0;                  //Count of beacon periods

//Return if it is time for full beacon scan or standard beacon period
bool is_full_beacon_scan() {
    return beacon_period_count % (NR_BEACON_PERIOD_PER_SCAN) == 0;
}</declaration>
		<location id="id6" x="-799" y="-680">
			<committed/>
		</location>
		<location id="id7" x="-510" y="-357">
			<name x="-782" y="-391">wait_beacon_period</name>
			<label kind="invariant" x="-782" y="-374">beacon_clocks[id] &lt;= BEACON_PERIOD</label>
		</location>
		<location id="id8" x="-510" y="-680">
			<name x="-501" y="-671">wait_full_beacon_scan</name>
		</location>
		<location id="id9" x="-510" y="-501">
			<name x="-501" y="-535">choose</name>
			<committed/>
		</location>
		<location id="id10" x="-799" y="-501">
			<name x="-790" y="-527">initial</name>
		</location>
		<init ref="id10"/>
		<transition>
			<source ref="id7"/>
			<target ref="id9"/>
			<label kind="guard" x="-485" y="-330">beacon_clocks[id] == BEACON_PERIOD</label>
			<label kind="assignment" x="-485" y="-313">beacon_clocks[id] = 0</label>
			<label kind="comments" x="-484" y="-348">End beacon period</label>
			<nail x="-195" y="-357"/>
			<nail x="-195" y="-493"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id9"/>
			<label kind="guard" x="-493" y="-739">beacon_period_count &lt; NR_MAX_FULL_BEACON</label>
			<label kind="synchronisation" x="-492" y="-722">do_full_beacon_scan[id]?</label>
			<label kind="assignment" x="-493" y="-705">beacon_clocks[id] = 0</label>
			<label kind="comments" x="-493" y="-756">Go to next beacon period</label>
			<nail x="-195" y="-680"/>
			<nail x="-195" y="-510"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id6"/>
			<label kind="guard" x="-739" y="-782">beacon_period_count == NR_MAX_FULL_BEACON</label>
			<label kind="synchronisation" x="-739" y="-765">do_full_beacon_scan[id]?</label>
			<label kind="comments" x="-739" y="-799">Max full beacon scans reached</label>
			<nail x="-561" y="-740"/>
			<nail x="-756" y="-740"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id10"/>
			<label kind="synchronisation" x="-790" y="-594">end_initial_full_beacon_scan[id]!</label>
			<label kind="comments" x="-790" y="-611">End initial full beacon scan</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id6"/>
			<label kind="synchronisation" x="-766" y="-653">end_initial_scan[id]?</label>
			<label kind="comments" x="-765" y="-671">Synhronize after a full beacon scan</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id7"/>
			<label kind="guard" x="-501" y="-450">!is_full_beacon_scan()</label>
			<label kind="synchronisation" x="-501" y="-433">do_beacon_scan[id]!</label>
			<label kind="assignment" x="-501" y="-416">beacon_period_count++</label>
			<label kind="comments" x="-501" y="-467">Do normal beacon period</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="guard" x="-501" y="-603">is_full_beacon_scan()</label>
			<label kind="synchronisation" x="-501" y="-586">do_full_beacon_scan[id]!</label>
			<label kind="assignment" x="-501" y="-569">beacon_period_count++</label>
			<label kind="comments" x="-501" y="-620">Do full beacon scan</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="-756" y="-476">do_initial_full_beacon_scan[id]?</label>
			<label kind="assignment" x="-756" y="-459">beacon_clocks[id] = 0</label>
			<label kind="comments" x="-756" y="-493">Start initial full beacon scan</label>
		</transition>
	</template>
	<template>
		<name>full_beacon_scan</name>
		<parameter>id_t id</parameter>
		<declaration>clock slot_clock;           //Handling slot timing
beacon_data local_beacon;   //Sent beacon saved locally
bool collision = false;     //True after collision
int sync_id = -1;           //Id to synchronize to 

bool is_connected() {
    return connected_check(id, sent_beacon.id);
}

//Schedule data and sync (first beacon only) when there is no collision
void handle_beacon(int my_id, int other_id) {
    if(!collision) {
        if(data_is_scheduled[my_id][other_id] == 0)
        {
            data_is_scheduled[my_id][other_id] = 1;
            nr_node_relations++;
        }
        if(sync_id == -1)
            sync_id = other_id;
    }
}

void reset_vars() {
    local_beacon.id = 0;
    collision = false;
}</declaration>
		<location id="id11" x="272" y="-374">
			<committed/>
		</location>
		<location id="id12" x="646" y="-374">
			<committed/>
		</location>
		<location id="id13" x="-59" y="-255">
			<committed/>
		</location>
		<location id="id14" x="535" y="-280">
			<committed/>
		</location>
		<location id="id15" x="-25" y="-374">
			<name x="-17" y="-374">during_full_beacon_scan</name>
			<label kind="invariant" x="-17" y="-357">beacon_clocks[id] &lt;= BEACON_PERIOD</label>
		</location>
		<location id="id16" x="-406" y="-577">
			<name x="-397" y="-577">during_beacon_scan</name>
			<label kind="invariant" x="-397" y="-560">beacon_clocks[id] &lt;= BEACON_SCAN</label>
		</location>
		<location id="id17" x="-408" y="-467">
			<committed/>
		</location>
		<location id="id18" x="-407" y="-340">
			<name x="-399" y="-374">initial</name>
		</location>
		<location id="id19" x="340" y="-374">
			<name x="365" y="-416">during_beacon</name>
			<label kind="invariant" x="365" y="-399">slot_clock &lt;= BEACON_SLOT</label>
		</location>
		<branchpoint id="id20" x="501" y="-195">
		</branchpoint>
		<branchpoint id="id21" x="272" y="-561">
		</branchpoint>
		<init ref="id18"/>
		<transition>
			<source ref="id11"/>
			<target ref="id21"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id19"/>
			<label kind="guard" x="374" y="-526">beacon_clocks[id] 
&lt;= BEACON_PERIOD - BEACON_SLOT</label>
			<label kind="assignment" x="374" y="-484">slot_clock = 0,
collision = true</label>
			<label kind="comments" x="374" y="-544">Chain the collision</label>
			<nail x="510" y="-442"/>
			<nail x="374" y="-442"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id12"/>
			<label kind="comments" x="501" y="-187">Collision</label>
			<label kind="probability" x="501" y="-170">BCN_NOT_LOST_PROB</label>
			<nail x="646" y="-195"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id19"/>
			<label kind="comments" x="374" y="-238">Beacon lost</label>
			<label kind="probability" x="373" y="-221">BCN_LOST_PROB</label>
			<nail x="364" y="-195"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id19"/>
			<label kind="assignment" x="272" y="-603">slot_clock = 0,
local_beacon = sent_beacon</label>
			<label kind="comments" x="272" y="-637">Beacon received</label>
			<label kind="probability" x="272" y="-620">BCN_NOT_LOST_PROB</label>
			<nail x="339" y="-561"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id15"/>
			<label kind="comments" x="17" y="-603">Beacon lost</label>
			<label kind="probability" x="17" y="-587">BCN_LOST_PROB</label>
			<nail x="8" y="-561"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id15"/>
			<label kind="guard" x="-391" y="-697">beacon_clocks[id] == BEACON_SCAN</label>
			<label kind="synchronisation" x="-391" y="-680">beacon_prepare_send_chan?</label>
			<label kind="assignment" x="-391" y="-663">is_busy[id] = true</label>
			<label kind="comments" x="-391" y="-714">Force end beacon scan</label>
			<nail x="-406" y="-645"/>
			<nail x="-66" y="-645"/>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id18"/>
			<label kind="guard" x="-366" y="-229">sync_id &gt;= 0</label>
			<label kind="synchronisation" x="-366" y="-212">end_initial_scan[id]!</label>
			<label kind="assignment" x="-364" y="-195">beacon_clocks[id] = beacon_clocks[sync_id]</label>
			<label kind="comments" x="-364" y="-246">Synchronize to first beacon</label>
			<nail x="-407" y="-255"/>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id18"/>
			<label kind="guard" x="-366" y="-314">sync_id == -1</label>
			<label kind="synchronisation" x="-364" y="-297">do_full_beacon_scan[id]!</label>
			<label kind="comments" x="-364" y="-331">No beacons to synchronize to</label>
			<nail x="-119" y="-272"/>
			<nail x="-383" y="-272"/>
			<nail x="-382" y="-306"/>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id13"/>
			<label kind="guard" x="-289" y="-374">beacon_clocks[id] == BEACON_PERIOD</label>
			<label kind="assignment" x="-291" y="-358">is_busy[id] = false</label>
			<label kind="comments" x="-289" y="-391">Beacon period ends</label>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id15"/>
			<label kind="guard" x="8" y="-255">slot_clock == BEACON_SLOT</label>
			<label kind="assignment" x="8" y="-238">handle_beacon(id, local_beacon.id),
reset_vars()</label>
			<label kind="comments" x="8" y="-272">End of beacon, handle data if no collision</label>
			<nail x="340" y="-195"/>
			<nail x="-24" y="-196"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id20"/>
			<nail x="501" y="-263"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id15"/>
			<label kind="guard" x="110" y="-680">beacon_clocks[id] &gt; BEACON_PERIOD - BEACON_SLOT</label>
			<label kind="assignment" x="109" y="-663">reset_vars()</label>
			<label kind="comments" x="110" y="-697">Beacon period ending soon</label>
			<nail x="646" y="-646"/>
			<nail x="-25" y="-646"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id14"/>
			<label kind="guard" x="372" y="-347">is_connected()</label>
			<label kind="synchronisation" x="372" y="-330">beacon_start_chan?</label>
			<label kind="comments" x="374" y="-365">Another beacon sent</label>
			<nail x="535" y="-374"/>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id15"/>
			<label kind="guard" x="-380" y="-603">beacon_clocks[id] == BEACON_SCAN</label>
			<label kind="comments" x="-380" y="-620">End beacon scan</label>
			<nail x="-100" y="-577"/>
		</transition>
		<transition>
			<source ref="id17"/>
			<target ref="id16"/>
			<label kind="guard" x="-391" y="-510">is_busy[id] == false</label>
			<label kind="synchronisation" x="-391" y="-493">do_beacon_scan[id]!</label>
			<label kind="comments" x="-391" y="-527">Begin beacon scan</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id17"/>
			<label kind="synchronisation" x="-398" y="-424">do_full_beacon_scan[id]?</label>
			<label kind="comments" x="-397" y="-441">Begin full beacon scan</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id11"/>
			<label kind="guard" x="8" y="-450">is_connected()
&amp;&amp; beacon_clocks[id] 
&lt;= BEACON_PERIOD - BEACON_SLOT</label>
			<label kind="synchronisation" x="7" y="-398">beacon_start_chan?</label>
			<label kind="comments" x="8" y="-467">Neighbor sending beacon</label>
		</transition>
	</template>
	<template>
		<name>beacon_scan</name>
		<parameter>id_t id</parameter>
		<declaration>//Nr beacon periods without sending
const int NR_BEACON_PERIODS_ONLY_LISTEN = 3;

clock beacon_slot_clock;     //Timing for a single beacon slot
beacon_data received_beacon; //Save received beacon
int current_slot = 0,        //The current slot in the interval
    nr_senders = 0,          //Track nr of beacons send to node
    nr_beacon_period = 0;    //Count toward sending

//Put beacon data global for receivers to retrieve
void put_beacon_global() {
    sent_beacon.id = id;
}

//Retreive beacon from global data
void retrieve_beacon() {
    received_beacon = sent_beacon;
}

void reset_beacon_global() {
    sent_beacon.id = 0;
}

void reset_local_beacon() {
    received_beacon.id = 0;
}

//Neighbor connected check
bool is_connected() {
    return connected_check(id, sent_beacon.id);
}

//Choose a a beacon slot to send in 
void choose_slot(int k) {
    if(nr_beacon_period &gt;= NR_BEACON_PERIODS_ONLY_LISTEN || initialized[id])
        chosen_slot[id] = k;
    else {
        chosen_slot[id] = -1;
        nr_beacon_period++;
    }   
}

void schedule_data() {
    if(nr_senders == 1 &amp;&amp; data_is_scheduled[id][received_beacon.id] == 0) {
        //Schedule data
        data_is_scheduled[id][received_beacon.id] = 1;
        nr_node_relations++;
    }
}

//Count to calculate percentage of beacon collisions
double nr_collisions = 0.0,
       nr_slots = 0.0,
       collision_percentage = 0.0;

//Update collision percentage for the beacon
/*void do_performance_calculations() {
    int i;
    bool send_collision = false;

    nr_slots = nr_slots + 1.0;

    if(chosen_slot[id] == current_slot)
    {
        for(i = 0; i &lt; NR_NODES; i++) {
            if(i != id &amp;&amp; connected_check(id, i)) {
                send_collision = true;
            }
        }
    }

    if(send_collision || nr_senders &gt;= 2) {
        nr_collisions = nr_collisions + 1.0;
    }

    if(nr_slots &gt; 0.0) {
            collision_percentage = 100*(nr_collisions / nr_slots);
    }
}*/</declaration>
		<location id="id22" x="25" y="161">
			<committed/>
		</location>
		<location id="id23" x="-170" y="-187">
			<name x="-247" y="-178">standy_until_others_prepared</name>
			<urgent/>
		</location>
		<location id="id24" x="-833" y="-272">
			<name x="-901" y="-306">end_send_slot</name>
			<committed/>
		</location>
		<location id="id25" x="-561" y="43">
			<committed/>
		</location>
		<location id="id26" x="-433" y="-272">
			<name x="-442" y="-323">wait_for_beacon_end</name>
			<label kind="invariant" x="-442" y="-306">beacon_slot_clock &lt;= BEACON_SLOT</label>
		</location>
		<location id="id27" x="-170" y="-272">
			<name x="-153" y="-281">listeners_prepared</name>
			<committed/>
		</location>
		<location id="id28" x="-833" y="323">
			<name x="-841" y="331">beacon_receive_end</name>
			<committed/>
		</location>
		<location id="id29" x="-255" y="161">
			<name x="-246" y="110">wait_for_beacon</name>
			<label kind="invariant" x="-246" y="127">beacon_slot_clock &lt;= BEACON_SLOT</label>
		</location>
		<location id="id30" x="-255" y="17">
			<name x="-238" y="9">choose_send_or_receive</name>
			<committed/>
		</location>
		<location id="id31" x="-841" y="17">
			<name x="-816" y="9">wait_for_beacon_interval</name>
		</location>
		<branchpoint id="id32" x="25" y="323">
		</branchpoint>
		<init ref="id31"/>
		<transition>
			<source ref="id22"/>
			<target ref="id32"/>
		</transition>
		<transition>
			<source ref="id32"/>
			<target ref="id29"/>
			<label kind="comments" x="-187" y="331">6/P12. Bacon lost</label>
			<label kind="probability" x="-187" y="348">BCN_LOST_PROB</label>
			<nail x="-221" y="323"/>
		</transition>
		<transition>
			<source ref="id32"/>
			<target ref="id29"/>
			<label kind="assignment" x="-187" y="263">retrieve_beacon(),
nr_senders++</label>
			<label kind="comments" x="-187" y="246">5/P12. Beacon not lost</label>
			<label kind="probability" x="-187" y="297">BCN_NOT_LOST_PROB</label>
			<nail x="-8" y="238"/>
			<nail x="-204" y="238"/>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id22"/>
			<label kind="guard" x="-187" y="187">is_connected()</label>
			<label kind="synchronisation" x="-187" y="204">beacon_start_chan?</label>
			<label kind="comments" x="-187" y="170">4/P12. Neighbor begins sending</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id27"/>
			<label kind="assignment" x="-161" y="-229">put_beacon_global()</label>
			<label kind="comments" x="-161" y="-246">11/P8-10. Make beacon available</label>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id24"/>
			<label kind="guard" x="-799" y="-314">beacon_slot_clock == BEACON_SLOT</label>
			<label kind="synchronisation" x="-799" y="-297">beacon_prepare_send_chan?</label>
			<label kind="comments" x="-799" y="-331">13/P10. A node waits for this node to prepare next slot</label>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id30"/>
			<label kind="assignment" x="-824" y="-170">current_slot++,
beacon_slot_clock = 0,
reset_beacon_global()</label>
			<label kind="comments" x="-824" y="-187">15/P6. End beacon send slot</label>
			<nail x="-833" y="-101"/>
			<nail x="-289" y="-102"/>
			<nail x="-289" y="-42"/>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id28"/>
			<label kind="guard" x="-603" y="221">beacon_slot_clock == BEACON_SLOT</label>
			<label kind="synchronisation" x="-603" y="238">beacon_prepare_send_chan?</label>
			<label kind="comments" x="-603" y="204">7/P12. A node waits for this node to prepare next slot</label>
			<nail x="-272" y="195"/>
			<nail x="-612" y="195"/>
			<nail x="-612" y="297"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id30"/>
			<label kind="select" x="-535" y="68">k:int[0, MAX_BEACON_NUMBER]</label>
			<label kind="assignment" x="-535" y="85">beacon_slot_clock = 0,
choose_slot(k)</label>
			<label kind="comments" x="-535" y="51">2/P2-5. Choose random beacon slot</label>
			<nail x="-314" y="43"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id24"/>
			<label kind="guard" x="-773" y="-238">beacon_slot_clock == BEACON_SLOT</label>
			<label kind="comments" x="-773" y="-255">14/P10. Beacon slot ends</label>
			<nail x="-501" y="-212"/>
			<nail x="-773" y="-212"/>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id23"/>
			<label kind="guard" x="-246" y="-110">beacon_slot_clock == 0
&amp;&amp; current_slot == chosen_slot[id]
&amp;&amp; current_slot &lt; NR_BEACON_SLOTS</label>
			<label kind="synchronisation" x="-246" y="-59">beacon_prepare_send_chan!</label>
			<label kind="comments" x="-246" y="-127">10/P7. Prepare sending beacon</label>
			<nail x="-255" y="-187"/>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id28"/>
			<label kind="guard" x="-535" y="297">beacon_slot_clock == BEACON_SLOT</label>
			<label kind="comments" x="-535" y="280">8/P12. Beacon slot ends</label>
			<nail x="-255" y="221"/>
			<nail x="-255" y="323"/>
			<nail x="-561" y="322"/>
		</transition>
		<transition>
			<source ref="id28"/>
			<target ref="id30"/>
			<label kind="assignment" x="-816" y="187">schedule_data(),
current_slot++,
reset_local_beacon(),
beacon_slot_clock = 0,
nr_senders = 0</label>
			<label kind="comments" x="-816" y="170">9/P6,12-15. Prepare for schedule data and end receive slot</label>
			<nail x="-833" y="153"/>
			<nail x="-289" y="154"/>
			<nail x="-289" y="77"/>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-382" y="-246">beacon_start_chan!</label>
			<label kind="comments" x="-382" y="-263">12/P10. Send data to receivers</label>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id29"/>
			<label kind="guard" x="-246" y="59">current_slot != chosen_slot[id]
&amp;&amp; current_slot &lt; NR_BEACON_SLOTS</label>
			<label kind="comments" x="-246" y="42">3/P11. Begin receving in 1 beacon slot</label>
		</transition>
		<transition>
			<source ref="id30"/>
			<target ref="id31"/>
			<label kind="guard" x="-705" y="-67">current_slot == NR_BEACON_SLOTS</label>
			<label kind="assignment" x="-705" y="-50">current_slot = 0,
is_busy[id] = false</label>
			<label kind="comments" x="-705" y="-84">16. End beacon interval</label>
			<nail x="-314" y="-8"/>
			<nail x="-790" y="-7"/>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id25"/>
			<label kind="guard" x="-790" y="69">!is_busy[id]</label>
			<label kind="synchronisation" x="-790" y="86">do_beacon_scan[id]?</label>
			<label kind="assignment" x="-790" y="103">is_busy[id] = true</label>
			<label kind="comments" x="-790" y="52">1. Beacon scan initiates</label>
			<nail x="-790" y="43"/>
		</transition>
	</template>
	<template>
		<name>send_data</name>
		<parameter>id_t id</parameter>
		<location id="id33" x="382" y="-102">
			<committed/>
		</location>
		<location id="id34" x="-434" y="0">
			<committed/>
		</location>
		<location id="id35" x="382" y="0">
			<name x="399" y="-25">prepare_send</name>
			<committed/>
		</location>
		<location id="id36" x="382" y="-178">
			<name x="289" y="-229">sending</name>
			<label kind="invariant" x="289" y="-212">send_data_clock[id] &lt;= DATA_DURATION</label>
		</location>
		<location id="id37" x="-110" y="0">
			<name x="-93" y="8">wait_for_send</name>
			<label kind="invariant" x="-93" y="25">send_data_clock[id] &lt;= data_intervals[id]</label>
		</location>
		<location id="id38" x="-434" y="-102">
			<name x="-450" y="-136">initialize</name>
		</location>
		<init ref="id38"/>
		<transition>
			<source ref="id36"/>
			<target ref="id37"/>
			<label kind="guard" x="-110" y="-297">send_data_clock[id] == DATA_DURATION</label>
			<label kind="assignment" x="-110" y="-280">is_busy[id] = false</label>
			<label kind="comments" x="-110" y="-314">Forced stop sending</label>
			<nail x="280" y="-195"/>
			<nail x="280" y="-255"/>
			<nail x="-153" y="-255"/>
			<nail x="-153" y="-51"/>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id36"/>
			<label kind="assignment" x="391" y="-136">aux_id = 0</label>
			<label kind="comments" x="391" y="-153">Reset global variable</label>
		</transition>
		<transition>
			<source ref="id34"/>
			<target ref="id37"/>
			<label kind="select" x="-408" y="25">k:int[0, MAX_DATA_OFFSET]</label>
			<label kind="assignment" x="-408" y="42">data_intervals[id] = DATA_INTERVAL + 4 * k</label>
			<label kind="comments" x="-408" y="8">Calculate data interval offset</label>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id37"/>
			<label kind="guard" x="-102" y="127">send_data_clock[id] == data_intervals[id]
&amp;&amp; (is_busy[id] 
|| (beacon_period_counters[id] == BEACON_SCAN_INTERVAL
    &amp;&amp; beacon_clocks[id] &gt; BEACON_PERIOD - DATA_DURATION))</label>
			<label kind="assignment" x="-102" y="196">send_data_clock[id] = 0</label>
			<label kind="comments" x="-102" y="110">Busy or about to do beacon scan</label>
			<nail x="-93" y="59"/>
			<nail x="127" y="59"/>
			<nail x="127" y="102"/>
			<nail x="-110" y="102"/>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id35"/>
			<label kind="guard" x="-68" y="-136">send_data_clock[id] == data_intervals[id]
&amp;&amp; !is_busy[id]
&amp;&amp; (beacon_period_counters[id] != BEACON_SCAN_INTERVAL
   || beacon_clocks[id] &lt;= BEACON_PERIOD - DATA_DURATION)</label>
			<label kind="assignment" x="-68" y="-59">aux_id = id,
is_busy[id] = true,
send_data_clock[id] = 0</label>
			<label kind="comments" x="-68" y="-153">Prepare sending data, if it does not overlap beacon scan</label>
		</transition>
		<transition>
			<source ref="id36"/>
			<target ref="id37"/>
			<label kind="guard" x="-110" y="-229">send_data_clock[id] == DATA_DURATION</label>
			<label kind="synchronisation" x="-110" y="-195">stop_sending_data?</label>
			<label kind="assignment" x="-110" y="-212">is_busy[id] = false</label>
			<label kind="comments" x="-110" y="-246">Done sending</label>
			<nail x="348" y="-178"/>
			<nail x="-110" y="-178"/>
		</transition>
		<transition>
			<source ref="id35"/>
			<target ref="id33"/>
			<label kind="synchronisation" x="390" y="-51">send_data_chan!</label>
			<label kind="comments" x="391" y="-68">Send to neighbor receivers</label>
		</transition>
		<transition>
			<source ref="id38"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="-425" y="-59">end_initial_full_beacon_scan[id]?</label>
			<label kind="assignment" x="-425" y="-42">send_data_clock[id] = 0</label>
			<label kind="comments" x="-425" y="-76">Start with beacon schedule</label>
		</transition>
	</template>
	<template>
		<name>receive_data</name>
		<parameter>id_t id</parameter>
		<declaration>clock receiving_data_clock;   //Receives data for a duration
int local_sender_id = 0;      //Save senders id locally

bool is_connected(int other_id) {
    return connected_check(id, other_id);
}

//We schedule at most 3 data transmissions at a time
//When the schedule reaches 0 it is no longer scheduled
void decrement_data_schedule(int my_id, int other_id) {
    data_is_scheduled[my_id][other_id]--;

    if(data_is_scheduled[my_id][other_id] == 0) 
        nr_node_relations--;
}

//Schedule the 3 next data transmissions
void schedule_data(int my_id, int other_id) {
    if(data_is_scheduled[my_id][other_id] == 0)
        nr_node_relations++;

    data_is_scheduled[my_id][other_id] = 3;
}</declaration>
		<location id="id39" x="221" y="119">
			<committed/>
		</location>
		<location id="id40" x="442" y="119">
			<committed/>
		</location>
		<location id="id41" x="136" y="-229">
			<name x="59" y="-220">prepare_sync</name>
			<committed/>
		</location>
		<location id="id42" x="-102" y="-93">
			<name x="-170" y="-119">cleanup</name>
			<committed/>
		</location>
		<location id="id43" x="204" y="-136">
			<name x="67" y="-188">collision</name>
			<label kind="invariant" x="68" y="-170">receiving_data_clock &lt;= DATA_DURATION</label>
		</location>
		<location id="id44" x="382" y="-229">
			<name x="399" y="-255">receiving_data</name>
			<label kind="invariant" x="399" y="-237">receiving_data_clock &lt;= DATA_DURATION</label>
		</location>
		<location id="id45" x="-102" y="17">
			<name x="-204" y="8">wait_for_data</name>
		</location>
		<branchpoint id="id46" x="501" y="119">
		</branchpoint>
		<init ref="id45"/>
		<transition>
			<source ref="id39"/>
			<target ref="id42"/>
			<label kind="guard" x="8" y="51">data_intervals[id] - DATA_DURATION &lt;  send_data_clock[id]</label>
			<label kind="comments" x="8" y="34">Overlap with sending data</label>
			<nail x="221" y="76"/>
			<nail x="0" y="76"/>
			<nail x="0" y="0"/>
		</transition>
		<transition>
			<source ref="id39"/>
			<target ref="id40"/>
			<label kind="guard" x="245" y="144">data_intervals[id] - DATA_DURATION &gt;=  send_data_clock[id]</label>
			<label kind="assignment" x="246" y="161">decrement_data_schedule(id, local_sender_id),
is_busy[id] = true</label>
			<label kind="comments" x="246" y="127">No overlap with sending</label>
		</transition>
		<transition>
			<source ref="id40"/>
			<target ref="id46"/>
		</transition>
		<transition>
			<source ref="id46"/>
			<target ref="id44"/>
			<label kind="comments" x="510" y="-119">Data is not lost</label>
			<label kind="probability" x="510" y="-102">DATA_NOT_LOST_PROB</label>
			<nail x="501" y="-136"/>
			<nail x="399" y="-136"/>
		</transition>
		<transition>
			<source ref="id46"/>
			<target ref="id42"/>
			<label kind="comments" x="102" y="-51">Data is lost</label>
			<label kind="probability" x="102" y="-34">DATA_LOST_PROB</label>
			<nail x="450" y="-8"/>
			<nail x="17" y="-8"/>
		</transition>
		<transition>
			<source ref="id44"/>
			<target ref="id41"/>
			<label kind="guard" x="161" y="-306">receiving_data_clock == DATA_DURATION</label>
			<label kind="assignment" x="161" y="-289">schedule_data(id, local_sender_id),
own_sync_id = id,
other_sync_id = local_sender_id</label>
			<label kind="comments" x="161" y="-323">Prepare synchronize</label>
		</transition>
		<transition>
			<source ref="id42"/>
			<target ref="id45"/>
			<label kind="assignment" x="-263" y="-85">is_busy[id] = false,
local_sender_id = 0,
receiving_data_clock = 0</label>
			<label kind="comments" x="-263" y="-102">Reset</label>
		</transition>
		<transition>
			<source ref="id43"/>
			<target ref="id42"/>
			<label kind="guard" x="-86" y="-109">receiving_data_clock == DATA_DURATION</label>
			<label kind="comments" x="-85" y="-127">Wait for data sending ends</label>
			<nail x="-85" y="-136"/>
		</transition>
		<transition>
			<source ref="id44"/>
			<target ref="id43"/>
			<label kind="guard" x="237" y="-109">is_connected(aux_id)</label>
			<label kind="synchronisation" x="236" y="-91">send_data_chan?</label>
			<label kind="comments" x="238" y="-127">Collision</label>
			<nail x="365" y="-136"/>
		</transition>
		<transition>
			<source ref="id41"/>
			<target ref="id42"/>
			<label kind="synchronisation" x="-102" y="-254">beacon_synchronize!</label>
			<label kind="comments" x="-102" y="-272">Tell scheduler to try synchronize</label>
			<nail x="-102" y="-229"/>
		</transition>
		<transition>
			<source ref="id45"/>
			<target ref="id39"/>
			<label kind="guard" x="-92" y="145">!is_busy[id]
&amp;&amp; initialized[id]
&amp;&amp; data_is_scheduled[id][aux_id] &gt; 0
&amp;&amp; is_connected(aux_id)
&amp;&amp; (beacon_period_counters[id] != BEACON_SCAN_INTERVAL
    || beacon_clocks[id] &lt;= BEACON_PERIOD - DATA_DURATION)</label>
			<label kind="synchronisation" x="-93" y="255">send_data_chan?</label>
			<label kind="assignment" x="-93" y="272">receiving_data_clock = 0,
local_sender_id = aux_id</label>
			<label kind="comments" x="-93" y="128">Begin receive data</label>
			<nail x="-102" y="119"/>
		</transition>
	</template>
	<template>
		<name>synchronizer</name>
		<location id="id47" x="0" y="0">
		</location>
		<init ref="id47"/>
		<transition>
			<source ref="id47"/>
			<target ref="id47"/>
			<label kind="guard" x="0" y="-161">beacon_clocks[own_sync_id] &gt;= beacon_clocks[other_sync_id] - (BEACON_PERIOD / 2)
&amp;&amp; beacon_clocks[own_sync_id] &lt;= beacon_clocks[other_sync_id] + (BEACON_PERIOD / 2)</label>
			<label kind="synchronisation" x="0" y="-127">beacon_synchronize?</label>
			<label kind="assignment" x="0" y="-110">beacon_clocks[own_sync_id] = beacon_clocks[other_sync_id],
other_sync_id = 0,
own_sync_id = 0</label>
			<label kind="comments" x="0" y="-178">Synchronize beacon schedule if criteria is fulfilled</label>
			<nail x="136" y="0"/>
			<nail x="136" y="-51"/>
			<nail x="0" y="-51"/>
		</transition>
	</template>
	<system>system beacon_schedule, beacon_scan, send_data, receive_data, full_beacon_scan, initial_full_beacon_scan, synchronizer;</system>
	<queries>
		<query>
			<formula>E&lt;&gt; exists(i:id_t) i != 0 &amp;&amp; !connected_check(0, i) &amp;&amp; beacon_interval(0).received_beacon.id == i
			</formula>
			<comment>Exists a time where node 0 received a beacon from a node that it was not connected to.
			</comment>
		</query>
		<query>
			<formula>A[] beacon_interval(0).received_beacon.id != 2
			</formula>
			<comment>In a line topology, node 0 will never receive a beacon from node 2
0 &lt;-&gt; 1 &lt;-&gt; 2
Assumption: Synchronized
			</comment>
		</query>
		<query>
			<formula>E&lt;&gt; data_is_scheduled[3][0]
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>simulate 1 [&lt;=50000] { 
data_is_scheduled[0][0] &gt; 0,
data_is_scheduled[0][1] &gt; 0,
data_is_scheduled[0][2] &gt; 0,
data_is_scheduled[0][3] &gt; 0,
data_is_scheduled[0][4] &gt; 0,
data_is_scheduled[0][5] &gt; 0,
data_is_scheduled[0][6] &gt; 0,
data_is_scheduled[0][7] &gt; 0,
data_is_scheduled[0][8] &gt; 0,
data_is_scheduled[0][9] &gt; 0,
data_is_scheduled[0][10] &gt; 0,
data_is_scheduled[0][11] &gt; 0,
data_is_scheduled[0][12] &gt; 0,
data_is_scheduled[0][13] &gt; 0,
data_is_scheduled[0][14] &gt; 0,
data_is_scheduled[0][15] &gt; 0
 }
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>Pr [&lt;= 60000] (&lt;&gt; nr_node_relations == 18)
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>simulate 1 [&lt;=150000] { full_beacon_scan(0).initial }
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>E&lt;&gt; exists(i:id_t) full_beacon_scan(i)._id16 &amp;&amp; is_busy[i] == true
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>simulate 10 [&lt;=300000] { nr_node_relations }
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>Pr[&lt;= 60000] (&lt;&gt; forall(i:id_t) beacon_schedule(i).wait_for_beacon_interval &amp;&amp; beacon_clocks[i] == 0)
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall(i:id_t) beacon_schedule(i).wait_for_beacon_interval &amp;&amp; beacon_clocks[i] == 0
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>simulate 1 [&lt;=3000] 
{ 
beacon_schedule(0).beacon_clock, 
beacon_schedule(1).beacon_clock,
beacon_schedule(2).beacon_clock,
beacon_schedule(3).beacon_clock, 
beacon_schedule(4).beacon_clock, 
beacon_schedule(5).beacon_clock, 
beacon_schedule(6).beacon_clock
}
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>simulate 1 [&lt;= 10000] 
{
beacon_interval(0).collision_percentage, 
beacon_interval(1).collision_percentage,
beacon_interval(2).collision_percentage,
beacon_interval(3).collision_percentage, 
beacon_interval(4).collision_percentage,
beacon_interval(5).collision_percentage,
beacon_interval(19).collision_percentage
}
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>Pr[1000,1500] (&lt;&gt; exists(i:id_t) beacon_interval(i).nr_senders &gt;= 2)
			</formula>
			<comment>Probability of a collision
			</comment>
		</query>
		<query>
			<formula>Pr[&lt;= 1500] (&lt;&gt; exists(i:id_t) beacon_interval(i).nr_senders &gt;= 2)
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A&lt;&gt; forall(i:id_t) beacon_scan(i).initialized
			</formula>
			<comment>Will all nodes eventually be initialized
			</comment>
		</query>
	</queries>
</nta>
